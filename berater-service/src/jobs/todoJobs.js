const cron = require('node-cron');
const Todo = require('../models/Todo');
const Contract = require('../models/Contract');
const User = require('../models/User');
const { cleanupOldAttachments } = require('./attachmentCleanup');
const Package = require('../models/Package');
const { sendContractExpirationReminder, sendPackageExpirationReminder, sendPackageDowngradeNotification } = require('../services/emailService');

/**
 * Generiert automatisch TODOs für ablaufende Verträge
 * Läuft täglich um 2:00 Uhr morgens
 */
const generateExpiringContractTodos = async () => {
  try {
    console.log('Starte automatische TODO-Generierung für ablaufende Verträge...');

    const today = new Date();
    const daysAhead = 90; // 90 Tage im Voraus
    const futureDate = new Date(today);
    futureDate.setDate(futureDate.getDate() + daysAhead);

    // Finde alle Verträge die in den nächsten 90 Tagen ablaufen
    const expiringContracts = await Contract.find({
      endDate: {
        $gte: today,
        $lte: futureDate
      },
      status: 'active'
    }).populate('customerId', 'firstName lastName');

    let createdCount = 0;
    let emailsSent = 0;

    for (const contract of expiringContracts) {
      // Hole Berater-Daten mit Einstellungen
      const berater = await User.findById(contract.beraterId);
      if (!berater) continue;

      const daysUntilExpiry = Math.ceil((contract.endDate - today) / (1000 * 60 * 60 * 24));

      // Prüfe ob der Vertrag innerhalb der Erinnerungszeit liegt
      const reminderDays = berater.settings?.reminderDays?.custom || 30;
      if (daysUntilExpiry > reminderDays) continue;

      // Prüfe ob bereits ein offenes TODO für diesen Vertrag existiert
      const existingTodo = await Todo.findOne({
        beraterId: contract.beraterId,
        relatedContractId: contract._id,
        autoGenerationType: 'contract_expiring',
        status: { $ne: 'completed' } // Nur offene TODOs prüfen
      });

      if (!contract.customerId) continue;

      // Priorität basierend auf prozentualem Anteil der verbleibenden Zeit
      // <= 33% der Zeit = high, <= 66% = medium, sonst low
      const percentRemaining = (daysUntilExpiry / reminderDays) * 100;
      const newPriority = percentRemaining <= 33 ? 'high' : percentRemaining <= 66 ? 'medium' : 'low';
      const newDescription = `Der Vertrag von ${contract.customerId.firstName} ${contract.customerId.lastName} läuft in ${daysUntilExpiry} Tagen ab. Bitte Verlängerung oder Kündigung vorbereiten.`;

      if (existingTodo) {
        // Bestehende TODO aktualisieren (Beschreibung und Priorität)
        existingTodo.description = newDescription;
        existingTodo.priority = newPriority;
        await existingTodo.save();
      } else {
        // Neues TODO erstellen
        await Todo.create({
          beraterId: contract.beraterId,
          title: `Vertrag ${contract.contractNumber} läuft ab`,
          description: newDescription,
          status: 'open',
          priority: newPriority,
          dueDate: contract.endDate,
          relatedCustomerId: contract.customerId,
          relatedContractId: contract._id,
          isAutoGenerated: true,
          autoGenerationType: 'contract_expiring'
        });

        createdCount++;

        // E-Mail nur bei neuer TODO senden (nicht bei Updates)
        if (berater.settings?.reminderDays?.sendEmail) {
          try {
            await sendContractExpirationReminder(berater, contract, daysUntilExpiry);
            emailsSent++;
          } catch (emailError) {
            console.error(`Fehler beim Senden der E-Mail für Vertrag ${contract.contractNumber}:`, emailError.message);
          }
        }
      }
    }

    console.log(`${createdCount} TODO(s) für ablaufende Verträge erstellt`);
    console.log(`${emailsSent} Erinnerungs-E-Mail(s) versendet`);
  } catch (error) {
    console.error('Fehler bei automatischer TODO-Generierung:', error);
  }
};

/**
 * Sendet Erinnerungs-E-Mails für ablaufende Pakete
 * Läuft täglich um 3:00 Uhr morgens
 * Sendet Erinnerungen bei 30, 14, 7, 3 und 1 Tag vor Ablauf
 */
const checkExpiringPackages = async () => {
  try {
    console.log('Prüfe ablaufende Pakete...');

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Erinnerungstage vor Ablauf
    const reminderDays = [30, 14, 7, 3, 1];
    let emailsSent = 0;

    // Finde alle Benutzer mit aktivem Paket und Ablaufdatum
    const usersWithSubscription = await User.find({
      'subscription.endDate': { $exists: true, $ne: null },
      'subscription.status': 'active',
      isActive: true,
      isBlocked: false
    });

    for (const user of usersWithSubscription) {
      if (!user.subscription?.endDate) continue;

      const endDate = new Date(user.subscription.endDate);
      endDate.setHours(0, 0, 0, 0);

      const diffTime = endDate.getTime() - today.getTime();
      const daysUntilExpiry = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      // Prüfe ob heute ein Erinnerungstag ist
      if (reminderDays.includes(daysUntilExpiry)) {
        try {
          await sendPackageExpirationReminder(user, daysUntilExpiry);
          emailsSent++;
          console.log(`Paket-Ablauf-Erinnerung gesendet an ${user.email} (${daysUntilExpiry} Tage verbleibend)`);
        } catch (emailError) {
          console.error(`Fehler beim Senden der Paket-Ablauf-E-Mail an ${user.email}:`, emailError.message);
        }
      }
    }

    console.log(`${emailsSent} Paket-Ablauf-Erinnerung(en) versendet`);
  } catch (error) {
    console.error('Fehler bei Paket-Ablauf-Prüfung:', error);
  }
};

/**
 * Downgradet abgelaufene Pakete automatisch auf das kostenlose Paket
 * Läuft täglich um 4:00 Uhr morgens
 */
const downgradeExpiredPackages = async () => {
  try {
    console.log('Prüfe abgelaufene Pakete für automatisches Downgrade...');

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Finde alle Benutzer deren Paket abgelaufen ist
    const expiredUsers = await User.find({
      'subscription.endDate': { $lt: today },
      'subscription.status': 'active',
      package: { $ne: 'free' }, // Nicht bereits auf free
      isActive: true,
      isBlocked: false
    });

    console.log(`${expiredUsers.length} Benutzer mit abgelaufenem Paket gefunden`);

    // Hole das kostenlose Paket
    const freePackage = await Package.findOne({ name: 'free' });
    if (!freePackage) {
      console.error('Kostenloses Paket nicht gefunden!');
      return;
    }

    let downgradedCount = 0;
    let emailsSent = 0;

    for (const user of expiredUsers) {
      const oldPackage = user.package;

      try {
        // Benutzer auf kostenloses Paket zurückstufen
        user.package = 'free';
        user.packageLimits = {
          maxCustomers: freePackage.maxCustomers,
          maxContracts: freePackage.maxContracts,
          maxMeters: freePackage.maxMeters
        };
        user.subscription.status = 'expired';

        await user.save();
        downgradedCount++;

        console.log(`Benutzer ${user.email} von ${oldPackage} auf free zurückgestuft`);

        // E-Mail-Benachrichtigung senden
        try {
          await sendPackageDowngradeNotification(user, oldPackage);
          emailsSent++;
        } catch (emailError) {
          console.error(`Fehler beim Senden der Downgrade-E-Mail an ${user.email}:`, emailError.message);
        }
      } catch (updateError) {
        console.error(`Fehler beim Downgrade für ${user.email}:`, updateError.message);
      }
    }

    console.log(`${downgradedCount} Benutzer auf kostenloses Paket zurückgestuft`);
    console.log(`${emailsSent} Downgrade-Benachrichtigung(en) versendet`);
  } catch (error) {
    console.error('Fehler bei automatischem Paket-Downgrade:', error);
  }
};

/**
 * Initialisiert alle Cron-Jobs
 */
const initializeJobs = () => {
  // Täglich um 2:00 Uhr morgens - TODO-Generierung
  cron.schedule('0 2 * * *', generateExpiringContractTodos);

  // Täglich um 2:00 Uhr morgens - Anhänge-Cleanup
  cron.schedule('0 2 * * *', cleanupOldAttachments);

  // Täglich um 3:00 Uhr morgens - Paket-Ablauf-Prüfung
  cron.schedule('0 3 * * *', checkExpiringPackages);

  // Täglich um 4:00 Uhr morgens - Automatisches Downgrade abgelaufener Pakete
  cron.schedule('0 4 * * *', downgradeExpiredPackages);

  console.log('Cron-Jobs initialisiert:');
  console.log('- Ablaufende Verträge: Täglich um 2:00 Uhr');
  console.log('- Anhänge-Cleanup (>3 Jahre): Täglich um 2:00 Uhr');
  console.log('- Paket-Ablauf-Erinnerungen: Täglich um 3:00 Uhr');
  console.log('- Paket-Downgrade nach Ablauf: Täglich um 4:00 Uhr');
};

module.exports = {
  initializeJobs,
  generateExpiringContractTodos,
  checkExpiringPackages,
  downgradeExpiredPackages
};
